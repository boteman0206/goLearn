package 图解redis系列

/**
一： 这些键值对是如何保存在 Redis 中的呢？
Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

二：Redis 的哈希桶是怎么保存键值对数据的呢？
参考图：redis底层结构图.png

三：Redis 设计了 SDS 结构来表示字符串？
 C 语言的字符串不足之处以及可以改进的地方：
	获取字符串长度的时间复杂度为 O（N）；
	字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；
	字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止


四： 链表


五： 压缩列表
压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。
压缩列表的缺陷也是有的：
	1：不能保存过多的元素，否则查询效率就会降低；
	2：新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。
压缩列表结构设计
	压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。
压缩列表在表头有三个字段：
	zlbytes，记录整个压缩列表占用对内存字节数；
	zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
	zllen，记录压缩列表包含的节点数量；
	zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。
查找效率：在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。、
		 而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。
压缩列表节点entry包含三部分内容：
	prevlen，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；
	encoding，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。
	data，记录了当前节点的实际数据，类型和长度都由 encoding 决定；
缺点： 连锁更新
	压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。
优化：
	虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。



哈希表
哈希表是一种保存键值对（key-value）的数据结构。
哈希表优点在于，它能以 O(1) 的复杂度快速查询数据
但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么哈希冲突的可能性也会越高。
Redis 采用了「链式哈希」来解决哈希冲突，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。、
typedef struct dictEntry {
    //键值对中的键
    void *key;

    //键值对中的值  dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表   还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希
    struct dictEntry *next;
} dictEntry;

rehash
哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表（ht[2]）。
随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：
	1：给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；
	2：将「哈希表 1 」的数据迁移到「哈希表 2」 中；
	3：迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。

渐进式 rehash
为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。
	1：给「哈希表 2」 分配空间；
	2：在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」 中索引位置上的所有 key-value 迁移到「哈希表 2」 上；
	3：随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。
在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。
比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。
另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。

rehash 触发条件











*/
