package 图解redis系列

/**

一：过期删除策略
	Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略

	1： 如何设置过期时间？
		1.1：先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：
			expire <key> <n>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；
			pexpire <key> <n>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。
			expireat <key> <n>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；
			pexpireat <key> <n>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）
		1.2：也可以同时对 key 设置过期时间，共有 3 种命令：
			set <key> <value> ex <n> ：设置键值对的时候，同时指定过期时间（精确到秒）；
			set <key> <value> px <n> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；
			setex <key> <n> <valule> ：设置键值对的时候，同时指定过期时间（精确到秒）。

		1.3： TTL <key> 如果你想查看某个 key 剩余的存活时间 查下 key1 的存活时间结果是 -1，表明 key1 永不过期
		1.4： 取消 key 的过期时间，则可以使用 PERSIST <key> 命令。

	2： 如何判定 key 已过期了？
		每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。
	3： 过期删除策略有哪些？
		1.1: 定时删除；
			在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。
			优点： 可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的
			缺点：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。
		1.2: 惰性删除；
			不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。
			优点： 因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。
			缺点：如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。
		1.3: 定期删除
			每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。
			优点： 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
			缺点：
				内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。
				难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

	4： Redis 过期删除策略是什么？
		Redis 选择「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。
	5： Redis 是怎么实现定期删除的？
		每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。
		1：从过期字典中随机抽取 20 个 key；
		2：检查这 20 个 key 是否过期，并删除已过期的 key；
		3：如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。
	那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms


二： 内存淘汰策略


*/
