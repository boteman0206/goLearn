

参考文档： https://juejin.cn/post/7034068713011839006

一：写数据流程： 参考图： es写数据流程.png
    1：客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node （协调节点）。
    2：coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。
    3：实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node 。
    4：coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端。



二：es 读数据过程 参考图：
    可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。

    1：客户端发送请求到任意一个 node，成为 coordinate node 。
    2：coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。
    3：接收请求的 node 返回 document 给 coordinate node 。
    4：coordinate node 返回 document 给客户端。


三：es 搜索数据过程
    1：客户端发送请求到一个 coordinate node 。
    2：协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard ，都可以。
    3：query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。
    4：fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。

    写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。


四：写数据底层原理：参考图：es写数据底层原理.png
    1：数据先写入内存 buffer ，同时写translog日志
    2：然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。
    3：每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。
    4： commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。

    数据写入 segment file 之后，同时就建立好了倒排索引。


五：translog 日志文件的作用是什么：
    你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，
    一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，
    es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。

    translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，
    如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。

  所以关于数据丢失问题，数据写入 1 秒后可以搜索到；
  可能会丢失数据的，有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 当中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。


六：删除/更新数据底层原理：
   1： 如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。
   2：如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。

    buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，
    此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，
    这里会写一个 commit point ，标识所有新的 segment file ，然后打开 segment file 供搜索使用，同时删除旧的 segment file 。


七：