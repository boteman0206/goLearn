package 垃圾回收

/**

https://mp.weixin.qq.com/s/up1MHqYW_v_C4P6AY-sW3w


1： Golang在GC的演进过程中也经历了很多次变革，截止在GoV1.8之前，Golang的GC改动还是非常的大，具体的几次重大改变如下：

  （1）Go V1.3之前的标记清除（Mark and Sweep）法。

  （2）Go V1.5的三色并发标记法。

  （3）Go V1.5 “强-弱” 三色不变式、插入屏障、删除屏障。

  （4）Go V1.8混合写屏障机制。



1.2： Go V1.3标记-清除算法
	接下来看一下在Golang V1.3之前的时候主要用的普通的标记清除算法，此算法主要有两个步骤：
	（1）标记（Mark Phase）。
	（2）清除（Sweep Phase）。
Mark and Sweep算法在执行的时候，需要程序暂停，即 STW（Stop The World）。STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，
所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕
	缺点： 标记清除算法简单明了，过程鲜明干脆，但是也有非常严重的问题，第一是STW这让程序暂停，程序也会出现卡顿 ，这是一个重要的问题；第二是标记需要扫描整个Heap；第三是清除数据会产生Heap碎片。

1.3： Go V1.5的三色标记法
Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户Goroutine可并发运行，但需要一定时间的STW，所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？本小节将介绍具体的过程。
  （1）： 第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，。
  （2）： 第二步, 每次GC回收开始，会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合，如图8所示。
  （3）： 第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
  （4）： 当全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。

1.4： Go V1.5的屏障机制
	（1）“强-弱”三色不变式： 不存在黑色对象引用到白色对象的指针，强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。
	（2）弱三色不变式： 所有被黑色对象引用的白色对象都处于灰色保护状态，弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象
	（3）插入屏障：插入屏障的具体操作是，在A对象引用B对象的时候，B对象被标记为灰色（将B挂在A下游，B必须被标记为灰色）。插入屏障实际上是满足强三色不变式（不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色）。插入屏障的伪码如下：
    （4）删除屏障： 删除屏障的具体操作是，被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。 删除屏障实际上是满足弱三色不变式，目的是保护灰色对象到白色对象的路径不会断
1.5： 混合写屏障（Hybrid Write Barrier）规则
	混合写屏障的具体操作一般需要遵循以下几个条件限制：
	（1）GC开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需STW）。
	（2）GC期间，任何在栈上创建的新对象，均为黑色。
	（3）被删除的对象标记为灰色。
	（4）被添加的对象标记为灰色。
注意 屏障技术是不在栈上应用的，因为要保证栈的运行效率。混合写屏障是GC的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。


1.6：小结
本章介绍了Golang中内存GC垃圾回收机制的演进迭代。发现GC的回收机制是一直在不断的优化，其目的是为了提高GC回收的性能。目前Golang的垃圾回收性能已经是非常的出色了，本章节只是介绍到了Go的1.8版本，Go的之后版本也有很多性能上的优化，但是几次变革较大的地方是本章要介绍了。

垃圾回收目前是三色标记加上屏障机制，影响垃圾回收性能的就是STW（Stop The World）机制，为了保护内存的安全性，不得不有STW，但是混合写屏障机制几乎可以完全不用STW来进行并行的垃圾回收，程序并不需要暂定就可以动态的清洗程序中的内存。

本章希望读者记住Golang中GC演进的几次里程碑，他们各自也都不是十分完美的解决方案，但通过对比我们可以得出 GoV1.3普通标记清除法，整体过程需要启动STW，效率极低。GoV1.5的三色标记加插入写屏障或删除写屏障方法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通。GoV1.8三色标记法加混合写屏障机制，栈空间不启动屏障机制，堆空间启动屏障机制。整个过程几乎不需要STW，效率较高。


*/
