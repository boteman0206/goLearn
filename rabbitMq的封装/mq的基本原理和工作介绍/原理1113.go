package mq的基本原理和工作介绍

/**
1: work工作模式下，消费者默认是轮训消费消息的
	1.1： 轮训分发
	1.2： 不公平分发（能者多劳）  消费方修改  r.channel.Qos(1)




2：自动应答和手动应答机制
	2.1： 自动应答以接收到消息为准，接收到消息则应答成功，不太可靠
	2.2： ack手动应答 multiple为批量参数   一般设置为false，只会应答当前的消息

	2.3： 如何保证消息不丢失（消息自动重新入队）
		1： 默认队列使用手动应答的机制，在处理完消息的时候进行ack应答
		2： 队列和交换机要进行持久化 (将队列由不持久改成持久的时候需要先删除，再生成，否则会报错)
		3： 对列中的消息也需要持久化（在生产者push消息的时候，可以执行消息的持久化属性）
			_publishing := amqp.Publishing{
				ContentType:  "text/plain",
				Body:         []byte(content),
				DeliveryMode: amqp.Persistent, // Transient 性能好，但是会丢数据。故用 Persistent
			}



		4: 发布确认：信道channel开启发布确认机制
			1： 单个发布确认（同步）， 发布一条消息之后只有他被确认发布成功，后续的消息才能继续发布 ： 速度慢
			2： 批量确认模式
			3： 异步确认模式





3： 死信队列(正产的队列通过参数设置死信队列和死信交换机，在正常队列的消息被拒绝或者消息已经过期或者队列达到最大长度的时候，会被转发到死信队列里面去)
	产生的原因： 1：消息被拒绝    2：消息的TTL过期 :3：队列达到最大的长度

4： 延迟队列，就是在死信队列里面的第二种情况，在消息过期的时候转到死信队列里面进行消费
	延迟队列的缺点是默认按照第一个消息设置的时间来判断的，可以通过下载插件，使用延迟交换机来实现



5： 发布确认高级知识点
	1： 交换机（宕机或者其他原因）收不到消息： 使用确认机制，未确认的消息可以存放到数据库
	2： 队列异常收不到消息， 这里可是设置回退到交换机
	3： 使用备份交换机来当主交换机无法投递消息的时候放到备份交换机中进行

6： 优先级队列（通过参数设置优先级队列）
	在发送消息的时候，可以对消息进行优先级的设置，优先级高的就会被先消费

7： 惰性队列 （通过参数设置优先级队列）
	（消息保存在内存还是磁盘中，正常情况下消息是保存在内存中的，在惰性队列中消息是保存在磁盘中的，消费速度慢）
	使用在消费者宕机，消息长时间挤压比较多的时候，可以使用惰性队列慢慢消费，可以不用占用内存




*/
