package 高阶知识点

/**
参考书籍 https://share.weiyun.com/5z6Ow6i

一：消息何去何从?
	1：mandatory和immediate是push发送消息方法中的两个参数，他们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。
		mandatory设为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么mq会调用basic.return命令将消息返回给生产者
		mandatory设为false时,出先以上情况直接丢弃

		immediate为true时，如果交换器在将消息路由到队列时候并不存在任何消费者，消息不会假日队列，该消息会通过basic.Return返回给生产者
		immediate为false时，则丢弃消息

	2：备份交换机
		rabbitMq提供的备份交换器将可以将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来，而不用返回给客户端
		不想使用mandatory参数，那样需要添加returnListener的编辑逻辑，生产者代码将变得复杂，这时候可以使用备份交换器，需要在申明交换器的时候添加alternate-exchange参数来实现，也可以通过策略的policy的方式实现，
		两者同时使用的时候，前者优先级更高，会覆盖掉policy的设置

二：过期时间TTL
	1： 设置消息的ttl
		mq只会判断队列的头消息是否过期，所有即使消息过期，如果不在头部也不会立即丢弃，因为要扫描所有的队列消息，性能损耗大
	2：设置队列的ttl（ttl超时会进入死信队列）
		申明队列的时候添加参数： x-message-ttl
		如果不设置ttl标识消息不过期，如果设置ttl=0则表示此时可以直接将消息投递到消费者，否则直接将消息丢弃


三： 死信队列
	1;消息被拒绝
	2：消息过期
	3;消息队列达到最大长度
	通过参数x-dead-letter-exchange来设置死信交换机，x-dead-letter-routing-key 指定路由键



四：延迟队列
	1：基于死信队列和ttl实现的延迟队列
	2; 基于插件实现的


五：优先级队列
	具有高优先级的队列具有很高的优先权，优先级高的消息具备优先被消费的特权。可以通过x-max-priority参实现
	1： 声明队列时增加一个参数
		// 官方允许是 0-255 之间 此处设置10 允许优化级范围0-10 不要设置过大 浪费CPU与内存
		arguments.put("x-max-priority", 10);

	2：发布消息时设置优先级 不能高于声明队列时设置的参数
		// 设置优先级, 不得高于 x-max-priority 设置的值
		AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().priority(5).build();


六：持久化与消息的可靠性
	1：交换器的持久化 durable参数设置
	2; 队列的持久化 durable参数设置，不持久化重启后队列丢失，元数据也会丢失
	3：数据的持久化，在push的时候将消息投递模式设置为deliveryMode=2即可实现
		可以将所有的消息都设置为持久化，但是会影响mq的性能，对于可靠性要求不是很高的消息可以不采取持久化处理以提高整体的吞吐量。
	4： 消费者端还需要开启ack确认模式，防止数据丢失
	5： 镜像队列解决消息到达mq但是还没有fsync落地到磁盘的这一段空隙时间，镜像队列相当于一个副本，主节点挂掉可以自动切换到从节点
    6：生产者确认模式（发送方并不知道消息是否是正真的到达了mq，所以需要确认机制）
		1：通过事务的方式确认（影响mq的性能）
		2：通过发送方confirm确认机制（常用）
			批量confirm：没发送一批消息后，调用waitfoeconfirm方法，等待服务器确认返回
			异步confirm： 提供一个回调方法，服务端确认一条或者多条消息后客户端会回调这个方法进行处理
	7：	事务和confirm机制是不能共存的，互斥的。同时开启会报错，事务机制和confirm只能保证消息能够到达mq，此时如果没有匹配的队列，那么消息也会丢失，
		更进一步讲，发送方要配合mandatory参数或者备份交换器一起使用来提高消息传输的可靠性。


七：消费端要点介绍
	1：消息分发
		当mq拥有多个消费者的时候，队列收到的消息将以轮询的方式分发给消费者。如果想要能者多劳模式需要开启Qos。Qos的使用对于拉模式的消费方式是无效的
			参数prefetchCount设置为0标识没有上限。
			prefetchSize参数标识消费者所能接收的未确认消息的总数，设置为0则没有上限。
			global参数：false标识信道上的新消费者需要遵从prefetchCount的限定值（一般默认设置为false），true标识信道上的所有消费者都要遵从
	2：消息的顺序性、
		只有单个生产者的情况下可以保证消息的顺序性
		1：如果多个生产者无法确定消息到达broker的前后顺序，也就无法验证消息的顺序性
		2： 开启事务机制，异常回滚的情况下也是无顺序的
		3：生产者设置了不同的超时时间也设置了死信队列，整体相当于一个延迟队列，消费者在消费这个延迟队列的时候消息的顺序也是无序的
		4：设置了优先级的队列
		5：消费端拒绝了，然后消息重新入队，消息无序
		要保证消息的顺序性需要业务方使用mq之后对消息添加全局有序标识来实现

	3; 弃用QueueingConsumer	java包中，消费的时候尽量不要使用继承defaultConsumer的方法，里面有一些坑


八：存储机制
	持久化的消息到达队列的时候就会被写入磁盘，如果可以还会在内存中保存一份。
	非持久化的消息只存储在内存中，在内存吃紧的时候会被换入到磁盘，已节省内存空间


九：惰性队列
	惰性队列会尽可能的将消息存在磁盘中，消费者消费到相应的消息时才会加载到内存中，他的重要的设计是能够支持更长的队列。惰性队列会尽可能的将消息存入磁盘中
	发送端过快或消费端宕机，导致消息大量积压，此时消息还是在内存和磁盘各存储一份，在消息大爆发的时候，MQ服务器会撑不住，影响其他队列的消息收发，能不能有效的处理这种情况呢。答案 惰性队列。
	通过参数 x-queue-mode：lazy 来设置惰性队列


十：镜像队列



十一： 消息的可靠性
	一般的消息中间件的消息传输保障分为三个层级
	1： at most once 最多一次，消息可能会丢失，但是绝不会重复传输
	2： at least once 最少一次。 消息绝不会丢失，但是可能会重复传输
	3： exactly once 恰好一次。 每条消息肯定会被传输一次且仅传输一次
	rabbitMq 支持其中的最多一次和最少一次。
    其中最少一次投递需要考虑以下几个方面的内容
   （1）：消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息的可靠传输到mq中
   （2）：消息生产者需要配合使用mandatory参数或者备份交换机来确保消息能够从交换器路由到队列中，进而能够保存下来而不会丢弃
   （3）：消息和队列都需要进行持久化处理，以确保mq服务器在遇到异常情况的时候不会造成消息丢失
   （4）：消费者需要手动ack消息，以避免在消费端引起不必要的消息丢失
   （5）：异步刷盘的时候需要可以使用镜像队列来保证消息的不丢失
   最多一次的方式就无需考虑以上的哪些方面，生产者随意发送，消费者随意消费，不过就是很难保证消息不丢失






*/
