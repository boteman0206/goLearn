package mysql学习

/**


https://zhuanlan.zhihu.com/p/164511591
https://cloud.tencent.com/developer/article/1491329
https://tech.meituan.com/2014/06/30/mysql-index.html
https://www.gxlcms.com/mysql-463427.html

https://zhuanlan.zhihu.com/p/352436463  全面了解MySQL的执行原理
https://zhuanlan.zhihu.com/p/142491549  MySQL 的 crash-safe 原理解析

一：mysql的分层：
	1：通过对mysql的两张图： mysql架构图.jpg和mysql的执行图.jpg我们知道 简单来说，MySQL主要分为 Server层 和 存储引擎层：
		Server层：主要包括连接器、查询缓存（MySQL8.0移除）、分析器、优化器、执行器等，所有的跨存储引擎的功能都在这一层实现，
			     比如存储过程、触发器、视图、函数等，还有一个通用的日志模块binglog
		存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnnoDB有属于自己的日志模块（下文会介绍到）。
				  「现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始被当做默认的存储引擎了。」



	2：查询缓存」（MySQL8.0后移除） 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。
		为什么MySQL8.0后要移除呢？
		因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。

	3: 数据页
		数据页是Innodb用于管理数据的最小磁盘单位，是一种物理结构，默认的页大小为16KB，每个页中至少存储有2条或以上的行记录。
		数据页有一部分会缓存在内存中，主要是为了提升性能。在数据库启动初始化就会加载一部分了，在进行增删改也会进行变更


日志：
	1：binlog（归档日志）是MySQL的Server层有的。 逻辑日志 主要记录用户对数据库操作的SQL语句 作用：正是由于binlog有归档的作用，所以binlog主要用作主从同步和数据库基于时间点的还原。
			1.1：binlog 属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠 binlog 是没有 crash-safe 能力的。
			1.2：binlog 有两种模式，statement 格式的话是记 sql 语句，row 格式会记录行的内容，记两条，更新前和更新后都有。
			1.3：sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

	2：undo log（回滚日志） redo log （重做日志）是 InnoDB 引擎特有的日志。物理日志
			undo log顾名思义，主要就是提供了回滚的作用，但其还有另一个主要作用，就是多个行版本控制(MVCC)，保证事务的原子性。
			在数据修改的流程中，会记录一条与当前操作相反的逻辑日志到undo log中（可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，
			反之亦然，当update一条记录时，它记录一条对应相反的update记录），如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的完整性，所以undo log也必不可少。
	3: redo log （重做日志）是 InnoDB 引擎特有的日志。物理日志
		记录的是数据库中每个页的修改，可以用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置，因为修改会覆盖之前的）
		redo log 是 InnoDB 存储引擎层的日志，又称重做日志文件，redo log 是顺序循环写的，相比于更新数据文件的随机写，日志的写入开销更小，能显著提升语句的执行性能，提高并发量。

	4:更新语句执行过程」 UPDATE` ``test` ``SET` ``c` = `c` + 1 ``WHERE` ``id` = 1;「操作顺序」 更新语句的redlog过程.jpg
		1：查找记录：执行器先找引擎取id=1这一行。ID是主键，引擎直接用树搜索找到这一行。如果id=1这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；
		2：「执行器」拿到引擎返回的行数据，把c+1，得到新的一行数据，再调用引擎接口写入这行新数据；
		2：引擎将这行新数据更新到「内存」中，同时「将这个更新之后的数据记录到redo log里面」，此时redo log处于「prepare」状态；
		4：引擎告知执行器，我执行完成了，你随时可以调我的接口提交事务了；
		5：执行器生成这个操作的binlog，并把「binlog」写入磁盘。
		6：执行器调用引擎的提交事务接口「，引擎把刚刚写入的redo log改成」提交commit状态，更新完成。

	5:「为什么redo log要分两步写，中间再穿插写binlog呢？
		5.1:「先写redolog并提交，然后再写binlog」，假设redolog写完后，机器宕机了，这个时候binlog没有写入，机器重新启动之后，
			 由于redo log已经写完了，系统重启后会通过redo log将数据恢复回来，但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，
			 如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的数据与原库的值不同。造成了主从不一致
		5.2:「先写 binlog，然后写 redo log」，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以没有记录到redolog。
			 但是binlog里面已经记录了日志。所以，在之后用binlog来恢复的时候，恢复出来的临时库中的数据就与原库的值不同。
		5.3: 在高并发的情况下，多个事务提交还需要加上锁
			在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。所以在早期的MySQL版本中，
			通过使用prepare_commit_mutex锁来保证事务提交的顺序，在一个事务获取到锁时才能进入prepare，一直到commit结束才能释放锁，下个事务才可以继续进行prepare操作。
			通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。除了锁的争用会影响到性能之外，
			还有一个对性能影响更大的点，就是每个事务提交都会进行两次fsync（写磁盘），
		    一次是redo log落盘，另一次是binlog落盘。大家都知道，写磁盘是昂贵的操作，对于普通磁盘，每秒的QPS大概也就是几百

		5.4：解决两段式提交的方案： 组提交-》mysql5.6
			binlog组提交的基本思想是，引入队列机制保证InnoDB commit顺序与binlog落盘顺序一致，并将事务分组，组内的binlog刷盘动作交给一个事务进行，实现组提交目的

	6：崩溃之后的数据恢复
		奔溃重启后会检查redo log中是完整并且处于prepare状态的事务，然后根据XID（事务ID），从binlog中找到对应的事务，如果找不到，则回滚；
		找到并且事务完整则重新commit redo log，完成事务的提交。
		6.1：时刻A（刚在内存中更改完数据页，还没有开始写redo log的时候奔溃）：
				因为内存中的脏页还没刷盘，也没有写redo log和binlog，即这个事务还没有开始提交，所以奔溃恢复跟该事务没有关系；
		6.2：时刻B（正在写redo log或者已经写完redo log并且落盘后，处于prepare状态，还没有开始写binlog的时候奔溃）：
				恢复后会判断redo log的事务是不是完整的，如果不是则根据undo log回滚；如果是完整的并且是prepare状态，则进一步判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log进行回滚；
		6.3：时刻C（正在写binlog或者已经写完binlog并且落盘了，还没有开始commit redo log的时候奔溃）：
				恢复后会跟时刻B一样，先检查redo log中是完整并且处于prepare状态的事务，然后判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log回滚，完整则重新commit redo log；
		6.4：时刻D（正在commit redo log或者事务已经提交完的时候，还没有反馈成功给客户端的时候奔溃）：
				恢复后跟时刻C基本一样，都会对照redo log和binlog的事务完整性，来确认是回滚还是重新提交。

	问题1：我想问下redo log为什么不能省掉啊，如果出现宕机，binlog也可以恢复啊？
			binlog无法确定哪些操作已经刷盘。

事务具有ACID的特性：
	show variables like 'autocommit';  默认MySQL中自动提交是开启的
	原子性(atomicity):事务中的所有操作要么全部提交成功，要么全部失败回滚。
	一致性(consistency):数据库总是从一个一致性状态转换到另一个一致性状态。
	隔离性(isolation):一个事务所做的修改在提交之前对其它事务是不可见的。
	持久性(durability):一旦事务提交，其所做的修改便会永久保存在数据库中。

事务的隔离级别：在SQL标准中定义了四种隔离级别：
	show variables like 'tx_isolation'; mysql 对应的InnoDB默认隔离级别是 重复读
	READ UNCOMMITTED(读未提交)：事务中的修改即使未提交也是对其它事务可见
	READ COMMITTED(读已提交)：事务提交后所做的修改才会被另一个事务看见，可能产生一个事务中两次查询的结果不同。
		就是一个事务要等另一个事务提交后才能读取数据。若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。
	REPEATABLE READ(可重读)：只有当前事务提交才能看见另一个事务的修改结果。解决了一个事务中两次查询的结果不同的问题。
		就是在开始读取数据（事务开启）时，不再允许修改操作。重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。
		但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
	SERIALIZABLE(串行化)：只有一个事务提交之后才会执行另一个事务。



 美团技术博客索引原理很重要： https://tech.meituan.com/2014/06/30/mysql-index.html
*/
