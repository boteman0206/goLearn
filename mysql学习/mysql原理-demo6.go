package mysql学习

/**


https://zhuanlan.zhihu.com/p/164511591
https://cloud.tencent.com/developer/article/1491329
https://tech.meituan.com/2014/06/30/mysql-index.html
https://www.gxlcms.com/mysql-463427.html

https://zhuanlan.zhihu.com/p/352436463


一：mysql的分层：
	1：通过对mysql的两张图： mysql架构图.jpg和mysql的执行图.jpg我们知道 简单来说，MySQL主要分为 Server层 和 存储引擎层：
		Server层：主要包括连接器、查询缓存（MySQL8.0移除）、分析器、优化器、执行器等，所有的跨存储引擎的功能都在这一层实现，
			     比如存储过程、触发器、视图、函数等，还有一个通用的日志模块binglog
		存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnnoDB有属于自己的日志模块（下文会介绍到）。
				  「现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始被当做默认的存储引擎了。」



	2：查询缓存」（MySQL8.0后移除） 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。
		为什么MySQL8.0后要移除呢？
		因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。


日志：
	1：binlog（归档日志）是MySQL的Server层有的。 逻辑日志 主要记录用户对数据库操作的SQL语句 作用：正是由于binlog有归档的作用，所以binlog主要用作主从同步和数据库基于时间点的还原。
			1.1：binlog 属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠 binlog 是没有 crash-safe 能力的。
			1.2：binlog 有两种模式，statement 格式的话是记 sql 语句，row 格式会记录行的内容，记两条，更新前和更新后都有。
			1.3：sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

	2：undo log（回滚日志） redo log （重做日志）是 InnoDB 引擎特有的日志。物理日志
			undo log顾名思义，主要就是提供了回滚的作用，但其还有另一个主要作用，就是多个行版本控制(MVCC)，保证事务的原子性。
			在数据修改的流程中，会记录一条与当前操作相反的逻辑日志到undo log中（可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，
			反之亦然，当update一条记录时，它记录一条对应相反的update记录），如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的完整性，所以undo log也必不可少。
	3: redo log （重做日志）是 InnoDB 引擎特有的日志。物理日志
		记录的是数据库中每个页的修改，可以用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置，因为修改会覆盖之前的）
		redo log 是 InnoDB 存储引擎层的日志，又称重做日志文件，redo log 是顺序循环写的，相比于更新数据文件的随机写，日志的写入开销更小，能显著提升语句的执行性能，提高并发量。

	4:更新语句执行过程」 UPDATE` ``test` ``SET` ``c` = `c` + 1 ``WHERE` ``id` = 1;「操作顺序」 更新语句的redlog过程.jpg
		1：查找记录：执行器先找引擎取id=1这一行。ID是主键，引擎直接用树搜索找到这一行。如果id=1这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；
		2：「执行器」拿到引擎返回的行数据，把c+1，得到新的一行数据，再调用引擎接口写入这行新数据；
		2：引擎将这行新数据更新到「内存」中，同时「将这个更新之后的数据记录到redo log里面」，此时redo log处于「prepare」状态；
		4：引擎告知执行器，我执行完成了，你随时可以调我的接口提交事务了；
		5：执行器生成这个操作的binlog，并把「binlog」写入磁盘。
		6：执行器调用引擎的提交事务接口「，引擎把刚刚写入的redo log改成」提交commit状态，更新完成。

	5:「为什么redo log要分两步写，中间再穿插写binlog呢？
		5.1:「先写redolog并提交，然后再写binlog」，假设redolog写完后，机器宕机了，这个时候binlog没有写入，机器重新启动之后，
			 由于redo log已经写完了，系统重启后会通过redo log将数据恢复回来，但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，
			 如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的数据与原库的值不同。造成了主从不一致
		5.2:「先写 binlog，然后写 redo log」，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以没有记录到redolog。
			 但是binlog里面已经记录了日志。所以，在之后用binlog来恢复的时候，恢复出来的临时库中的数据就与原库的值不同。

*/
