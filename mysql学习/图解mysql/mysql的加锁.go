package 图解mysql

/**

https://mp.weixin.qq.com/s/Ef73pSWb_k6yiTTlNCrEjg 小林coding

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。

1:什么 SQL 语句会加行级锁？
	普通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过  MVCC（多版本并发控制）实现的。
	如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。
		1: select ... lock in share mode;  //对读取的记录加共享锁(S型锁)
		2: select ... for update;  //对读取的记录加独占锁(X型锁)
	除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁。
		3: updaet table .... where id = 1;  //对操作的记录加独占锁(X型锁)
		4: delete from table where id = 1; //对操作的记录加独占锁(X型锁)
	共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。

2: 行级锁有哪些种类？
	2.2: 在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。
	2.2: 在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：
		1: Record Lock，记录锁，也就是仅仅把一条记录锁上；
			Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
				当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
				当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

		2: Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
            Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
			假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
			注意点： 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。


		3: Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
			Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
			假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。
			所以，next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。
			注意点： next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。



三： MySQL 是怎么加行级锁的？
	1： 分析加锁的命令： select * from performance_schema.data_locks\G;
		LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。
		通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：
			1.1： 如果 LOCK_MODE 为 X，说明是 next-key 锁；
			1.2： 如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁；
			1.3： 如果 LOCK_MODE 为 X, GAP，说明是间隙锁；
		根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK_DATA 是 5
		在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (xxx, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 xxx 的这一些新记录。

	加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。
	但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。
	2： 唯一索引等值查询
		当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同
		2.1： 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
		2.2： 当查询的记录是「不存在」的，则会在索引树找到第一条大于该查询记录的记录，然后将该记录的索引中的 next-key lock 会退化成「间隙锁」。
	3： 唯一索引范围查询 （范围查询和等值查询的加锁规则是不同的。）
		当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：
			1： 情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。
			2： 情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：
				当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
				当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
	4： 非唯一索引等值查询
		当我们用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁
		针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：
			1：当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，
   				直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，
				该二级索引的  next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
			2：当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的  next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。





*/
