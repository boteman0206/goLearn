
参考文章 https://zhuanlan.zhihu.com/p/273666774

1：基础知识：
    map的实现主要方式有两种 1： 哈希表（hash table）
                          2： 搜索树 （search tree）
    例如Java中的hashMap是基于哈希表实现，而C++中的Map是基于一种平衡搜索二叉树——红黑树而实现的。以下是不同实现方式的时间复杂度对比。（参见图片：map复杂度.jpg）


    hash表的两个概念：
        1：哈希函数  哈希函数（常被称为散列函数）是可以用于将任意大小的数据映射到固定大小值的函数，常见的包括MD5、SHA系列等。
        2：哈希冲突  哈希函数是将任意大小的数据映射到固定大小值的函数。那么，我们可以预见到，即使哈希函数设计得足够优秀，几乎每个输入值都能映射为不同的哈希值。
           但是，当输入数据足够大，大到能超过固定大小值的组合能表达的最大数量数，冲突将不可避免！
              2.1：解决hash冲突的方法 比较常用的Has冲突解决方案有链地址法和开放寻址法。
                    2.1.1： 在讲链地址法之前，先说明两个概念。
                            2.1.1.1： 哈希桶。哈希桶（也称为槽，类似于抽屉原理中的一个抽屉）可以先简单理解为一个哈希值，所有的哈希值组成了哈希空间
                            2.1.1.2： 装载因子。装载因子是表示哈希表中元素的填满程度。它的计算公式：装载因子=填入哈希表中的元素个数/哈希表的长度。装载因子越大，
                                      填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，
                                      而且还会提高扩容操作的次数。装载因子也是决定哈希表是否进行扩容的关键指标，在java的HashMap的中，其默认装载因子为0.75；Python的dict默认装载因子为2/3。
                    2.1.2： 链地址法 链地址法的思想就是将映射在一个桶里的所有元素用链表串起来。
                            （如图链地址方法.jpg） 链地址法解决冲突的方式与图的邻接表存储方式在样式上很相似，发生冲突，就用单链表组织起来。
                    2.1.3:  开放寻址法
                                    对于链地址法而言，槽位数m与键的数目n是没有直接关系的。但是对于开放寻址法而言，所有的元素都是存储在Hash表当中的，
                                    所以无论任何时候都要保证哈希表的槽位数m大于或等于键的数据n（必要时，需要对哈希表进行动态扩容）。
                                    开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。这里以线性探测法来帮助读者理解开放寻址法思想。
                                    (如图 线性探测法.jpg)

2： Go中map的基于哈希表（也被称为散列表）实现，它解决哈希冲突的方式是链地址法，即通过使用数组+链表的数据结构来表达map。

3： Go map的数据结构
     map中的数据被存放于一个数组中的，数组的元素是桶（bucket），每个桶至多包含8个键值对数据。哈希值低位（low-order bits）用于选择桶，
     哈希值高位（high-order bits）用于在一个独立的桶中区别出键。哈希值高低位示意图如下（map数据结构.jpg）

4： bmap也就是bucket（桶）的内存模型图解如下 （图bmap内存模型.jpg）
    此外：在8个键值对数据后面有一个overflow指针，因为桶中最多只能装8个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过overflow指针链接起来。

5: 触发的扩容因子的  6.5
    loadFactorNum = 13
    loadFactorDen = 2   // 触发扩容的装载因子为13/2=6.5
    5.1: 扩容分为增量扩容和等量扩容。
        5.1.1: 判断已经达到装载因子的临界点，即元素个数 >= 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到6.5个），
               如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。 进行增量扩容，会增加桶的个数（增加一倍），把原来一个桶中的 keys 被重新分配到两个桶中。
        5.1.2： 或者多次增删操作，造成溢出桶过多，判断溢出桶是否太多，当桶总数 < 2 ^ 15 时，如果溢出桶总数 >= 桶总数，则认为溢出桶过多。当桶总数 >= 2 ^ 15 时，
                直接与 2 ^ 15 比较，当溢出桶总数 >= 2 ^ 15 时，即认为溢出桶太多了。等量扩容，不会更改桶的个数，只是会将桶中的数据变得紧凑。
        不管是增量扩容还是等量扩容，都需要创建新的桶数组，并不是原地操作的。
    5.2：扩容过程是渐进性的
          主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素， 桶搬迁的时机则发生在赋值、删除期间，
          每次最多搬迁两个 桶。查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置，需要重点理解。一旦理解，关于 map 的源码就可以看懂了。
6：完整的map结构.png

