package main

/**
Go 的代码库中为开发人员提供了一下两种锁：

互斥锁 sync.Mutex
读写锁 sync.RWMutex

互斥锁：
	第一个互斥锁指的是在 Go 编程中，同一资源的锁定对各个协程是相互排斥的，当其中一个协程获取到该锁时，
	其它协程只能等待，直到这个获取锁的协程释放锁之后，其它的协程才能获取。

读写锁：
	第二个读写锁依赖于互斥锁的实现，这个指的是当多个协程对某一个资源都是只读操作，那么多个协程可以获取该资源的读锁，
	并且互相不影响，但当有协程要修改该资源时就必须获取写锁，如果获取写锁时，已经有其它协程获取了读写或者写锁，那么此次获取失败，
	也就是说读写互斥，读读共享，写写互斥

todo 使用 - race 在运行时检测数据竞争问题，go test -race ....，go build -race ....

互斥锁的基本结构：
type Locker interface {
   Lock()
   Unlock()
}
type Mutex struct {
   state int32 //初始值默认为0   state表示互斥锁的状态，比如是否被锁定等。 state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态
   sema  uint32 //初始值默认为0  sema表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。
}

------------------------------------
const (
   mutexLocked = 1 << iota //1, 0001 最后一位表示当前锁的状态，0未锁，1已锁
   mutexWoken //2, 0010，倒数第二位表示当前锁是否会被唤醒 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。释放锁时，如果正常模式下，不会再唤醒其它协程。
   mutexStarving //4, 0100 倒数第三位表示当前对象是否为饥饿模式,0正常，1饥饿说明有协程阻塞了超过1ms
   mutexWaiterShift = iota //3 从倒数第四位往前的bit表示排队的gorouting数量 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量
   starvationThresholdNs = 1e6 // 饥饿的阈值：1ms
）
//Mutex中的变量，这里主要是将常量映射到state上面
state //0代表未获取到锁，1代表得到锁，2-2^31表示gorouting排队的数量的
sema //非负数的信号量，阻塞协程的依据 Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。
------------------------------------------

Mutex 实现中有两种模式，
1：正常模式，
2：饥饿模式，
前者指的是当一个协程获取到锁时，后面的协程会排队 (FIFO), 释放锁时会唤醒最早排队的协程，这个协程会和正在 CPU 上运行的协程竞争锁，但是大概率会失败，为什么呢？
因为你是刚被唤醒的，还没有获得 CPU 的使用权，而 CPU 正在执行的协程肯定比你有优势，如果这个被唤醒的协程竞争失败，并且超过了 1ms，
那么就会退回到后者 (饥饿模式)，这种模式下，该协程在下次获取锁时直接得到，不存在竞争关系，本质是为了防止协程等待锁的时间太长。

如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。
相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。




*/

func main() {

}
