package http和tcp

/**

参考文档：
https://juejin.cn/post/6974673084095660062


什么是http协议



0：HTTP 0.9
	HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。

1：http1.0
	1.1：增加了请求方式POST和HEAD；
	1.2：请求行必须在尾部添加协议版本字段（http/1.0），每次通信都必须包括头信息（HTTP header），用来描述一些元数据
	1.3: 不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；
	1.4: 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
 	主要缺点：
		但是1.0版本的工作方式是每次TCP连接只能发送一个请求（默认短链接），当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keep-alive。

	TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。
	为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。  Connection: keep-alive
2：http1.1
	2.1：1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。
		 解决了1.0版本的keepalive问题，一个TCP连接可以允许多个HTTP请求；客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
	2.2：加入了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率；举例来说，客户端需要请求两个资源。
		以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
    2.3：新增了请求方式PUT、PATCH、OPTIONS、DELETE等。
	2.4：客户端请求的头信息新增了Host字段，用来指定服务器的域名。 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
	2.5：新增Content-Length 字段：一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。
		 在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。

	缺点：（队头阻塞）
		虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。
        服务端是按队列顺序处理请求的，服务器只有处理完一个回应，才会进行下一个回应。假如前面的请求处理时间很长，后面就会有许多请求排队等着，这样就造成了“队头阻塞”的问题；
		同时HTTP是无状态的连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。

3：http2.0 (为了解决1.1版本利用率不高的问题，提出了HTTP/2.0版本)
	3.1: 增加双工模式  即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）
	3.2: HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率。
	3.3: 增加服务器推送的功能，即不经请求服务端主动向客户端发送数据


4：http3.0  QUIC其实是Quick UDP Internet Connections的缩写，直译为快速UDP互联网连接。
	4.1: 其弃用TCP协议，改为使用基于UDP协议的QUIC协议来实现。


6： 长连接和短链接
   	短连接：客户端和服务端进行收发数据的时候才进行连接，一次收发消息后就进行断开。、
			优点：管理起来比较简单，存在的连接都是有用的连接
	长连接：双方建立连接，一次读写之后不会主动断开。
			优点：省去了TCP连接和关闭的时间，节省了时间，频繁请求的用户适合长连接，
			缺点：是如果有人恶意攻击，产生大量的长连接，会使服务器受损。所以可以关闭一些长时间不用的连接，以及限制客户端的最大连接数


7: 队头阻塞问题
	7.1: HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。
	7.2: TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，
 		 如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。
	7.3：QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。


1. TCP队头阻塞
	TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。

2. HTTP队头阻塞
	http队头阻塞和TCP队头阻塞完全不是一回事。
	http1.x采用长连接(Connection:keep-alive)，可以在一个TCP请求上，发送多个http请求。
	有非管道化和管道化，两种方式。
	非管道化，完全串行执行，请求->响应->请求->响应...，后一个请求必须在前一个响应之后发送。
	管道化，请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。


8： HTTP1.x的缺点
	8.1: HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，
         仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
	8.2: 单向请求，只能由客户端发起。
	8.3: 请求报文与响应报文首部信息冗余量大。
	8.4: 数据未压缩，导致数据的传输量大。

9: HTTP2.0特点
	9.1: 二进制传输  HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据
	9.2: 多路复用
		HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
		帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
		所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。
	9.3: Header压缩
		在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。
		在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。
	9.4: 服务器Push 在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源
		可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。
	9.5: 更安全
		HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。
10: HTTP2.0缺点
	10.1： 建立连接时间长(本质上是TCP的问题)
	10.2： 队头阻塞问题
	10.3： 移动互联网领域表现不佳(弱网环境)
			。。。。。

https://github.com/FIGHTING-TOP/FE-knowlodge-base/issues/3
https://zhuanlan.zhihu.com/p/72616216
11：HTTP
Http: HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。
	一般http中存在如下问题：
	1: 请求信息明文传输，容易被窃听截取。
	2: 数据的完整性未校验，容易被篡改
	3: 没有验证对方身份，存在冒充危险

12: HTTPS:
	12.1: HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。
    12.2: SSL又是什么？
		SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。
		TLS（Transport Layer Security，传输层安全）: 其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。
13: 浏览器在使用HTTPS传输数据的流程是什么？
	13.1：首先客户端通过URL访问服务器建立SSL连接。服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
	13.2：客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
	13.3：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
	13.4：服务器利用自己的私钥解密出会话密钥。
	13.5：服务器利用会话密钥加密与客户端之间的通信。

14： HTTPS的缺点
	HTTPS协议多次握手，导致页面的加载时间延长近50%；
	HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
	申请SSL证书需要钱，功能越强大的证书费用越高。
	SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。
15.总结HTTPS和HTTP的区别
	1: HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。
	2: HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
	3: http和https使用连接方式不同，默认端口也不一样，http是80，https是443。
	4: HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

16: HTTPS 解决了 HTTP 的哪些问题？
	HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决窃听风险,篡改风险,冒充风险，：
	混合加密的方式实现信息的机密性，解决了窃听的风险
	摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险
	将服务器公钥放入到数字证书中，解决了冒充的风险。


11：HTTP2.0
1. 头部压缩 HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
2. 二进制格式 HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame）。
3. 并发传输 我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了队头阻塞的问题
	而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。
	针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。
4、服务器推送 HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息。

19: HTTP2.0的缺点
HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。
HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，
那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

HTTP/3 做了哪些优化
前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：
HTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！、
大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。
QUIC 有以下 3 个特点。
无队头阻塞  QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。
更快的连接建立 对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手
			HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。
连接迁移 基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。
		那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。
		而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。


HTTP/3的缺点：
QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。
*/
